package chapter3;

import java.util.ArrayList;
import java.util.List;

// 제너릭 : 클래스나 메서드에서 사용할 데이터 타입을 외부에서 받아오는 기법

// Test1, Test2, Test3 형태로 클래스를 작성하면 코드 중복 발생
class Test1 {
	String subject;
	int score;
}

class Test2 {
	String subject;
	double score;
}

class Test3 {
	String subject;
	char score;
}

// Test4 형태의 클래스로 작성하면 코드의 중복은 해결할 수 있지만
// 사용시 타입의 안전성이 떨어짐
class Test4 {
	String subject;
	Object score;
}

// 제너릭 클래스 : 클래스 내부에 있는 데이터 타입을 컴파일 시에 결정하게 함
// class 클래스명<매개타입> { 매개타입 변수명; ... }
class Test5<T> {
	String subject;
	T score;
}

class SuperClass {}

class MyClass extends SuperClass {}

class SubClass extends MyClass{}

// T extends 클래스명 : 특정 클래스 혹은 특정 클래스를 상속한 클래스 
class ExtendsClass<T extends MyClass> {
	T variable;
}


public class Generic {
	
	// 메서드에서 타입을 지정하면 메서드를 호출하여 필요할 때 타입을 지정하여 사용할 수 있다.
	// 제너릭 메서드 : 해당 메서드이 매개변수의 타입이나 반환 타입을 컴파일시에 결정하고자 할 때 사용
	// <매개타입> 반환타입 메서드명 (매개변수) { ... } 
	static <T> void method (List<T> arg) {
		System.out.println(arg);
	}
	
	static void wildMethod (List<?> arg) {
		System.out.println(arg);
	}
	
	public static void main(String[] args) {

		Test4 instance1 = new Test4();
		instance1.score = 'A';
		
		int score = (int)instance1.score;
		System.out.println(score);
		
		Test5<Integer> instance2 = new Test5<>();
		instance2.score = 10;
		score = instance2.score;
		
		List<SuperClass> list1 = new ArrayList<SuperClass>();
		list1.add(new MyClass());
		list1.add(new SubClass());
		list1.add(new SuperClass());
		
//		ExtendsClass<MyClass> instance3 = new ExtendsClass<MyClass>();
		
	}

}
